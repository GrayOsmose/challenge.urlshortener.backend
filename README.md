# The Challenge

## Description

I was asked to create an application for url shrotener. Backend should be done on .Net or .Net Core. I've picked .Net Core 1.1 web api. With database and stuff. Without authentification. The clicks on shortened urls should be tracked. 

## Architecture

It's a basic layered architecture with seperated access layer to data, model and application which uses them via dependecy injection.

## Components

- .Net core 1.1 web api
- MongoDB

## How it was done

Going from the top, web api till the access layer.

### .Net Core 1.1 WebApi

We don't need authentification for user data access, but tracking incoming requests is still needed. I could've used `Session` (and I did at some point just to check things out), but that goes against `RESTfull` policy. So I've implemented my own `CookieIdentityMiddleware` and used it in `Startup`.

```cs
public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
{
    ...
    
    // use identity cookie middleware to track connection
    app.CookieIdentityMiddleware();

    ...
}
```

`UserData` is then used in controller from `HttpContext`

```cs
private Guid UserData
{
    // get my user
    get { return (Guid)HttpContext.Items["User"]; }
}
```

The only downside is that on rerouting `UserData` is still generated. That can be handled with options for middleware, a little twicking for future refactoring.

For `dependency injection` I've used the one provided with .net core webpai. DI fanciness goes beyond the scope of this challenge.

Also I had to temper with `Cors`, by allowing anything. It had to be done since anyone can access api for rerouting. Yes, it defenetly can be configured for certain routes and accept data only from certain endpoints, but this takes time and research.

Application should `generate key` for provided url. I've researched some algorithms which can helkp with that. The key can be generated for `url + userGuid`, since we need unique key for each url and user. On rerouting the key can be parsed and `used for rerouting`. For now `KeyManager` simply makes a Guid, without parsing and generating data from userGuid and url.

### Access Layer

Application uses `IUrlManager` for url management, which provides functionality to work with urls, CRUD oprations and click incremention.
`UrlModel` provides information for url, which are
- _id (it's a mongo id which should be removed in the future)
- Key (Generated by `KeyManger`)
- UserGuid (For user traking)
- Url (original)
- CreationDate
- ClickCount

`MongoStarter` is a simple helper. It creates collection from provided `connectionString` and `collecitonName`.

`UrlManagerMongo` the most interesting thing about manager is counter incrementation. It's managed by mongo itself, quite common operation it seems.

```cs
public async Task AddCounter(string key)
{
    await _collection.UpdateOneAsync(Builders<UrlModel>.Filter.Eq(x => x.Key, key),
                                     Builders<UrlModel>.Update.Inc(x => x.ClickCount, 1));
}
```

### Unit testing

Unfortunatly `Moq` and other libraries are `incompetable` with `.Net Core 1.1` (found out about it after dal and api completion, not pure tdd). There're a lot to test:
- Model validation on post, done with attributes
- Key validation for delete and rerouting

### Integration testing

Mongo and WebApi should be tested, but they aren't since time is was running out.

I would defenetly like to test `adding counters concurrently` (mongo should handle it).